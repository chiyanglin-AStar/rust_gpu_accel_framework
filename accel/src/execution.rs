//! Typed CUDA Kernel launcher
//!
//! This will be automatically implemented in [accel::kernel] for auto-generated [Module].
//!
//! ```
//! #[accel::kernel]
//! fn f(a: i32) {}
//! ```
//!
//! will create a submodule `f` (same name of the function):
//!
//! ```
//! mod f {
//!     pub const PTX_STR: &str = "PTX string generated by rustc/nvptx64-nvidia-cuda";
//!     pub struct Module(::accel::Module);
//!     /* impl Module { ... } */
//!     /* impl Launchable1 for Module { ... } */
//! }
//! ```
//!
//! Implementation of `Launchable1` for `f::Module` is also generated by [accel::kernel].
//! For a function which takes N arguments, `Launchable{N}` will be implemented for corresponding module.
//!
//! [accel::kernel]: ../attr.kernel.html
//! [Module]: ../module/struct.Module.html

use crate::{contexted_call, device::*, error::*, *};
use cuda::*;
use std::{ffi::*, ptr::null_mut};

/// Type which can be sent to the device as kernel argument
pub trait DeviceSend {
    /// Type on device
    type Target;
    fn as_kernel_parameter(&self) -> *mut c_void {
        self as *const Self as *mut c_void
    }
}

impl<T: Sized> DeviceSend for *mut T {
    type Target = Self;
}

impl<T: Sized> DeviceSend for *const T {
    type Target = Self;
}

macro_rules! impl_device_send {
    ($pri:ty) => {
        impl DeviceSend for $pri {
            type Target = Self;
        }

        impl<'arg> DeviceSend for &'arg $pri {
            type Target = Self;
        }

        impl<'arg> DeviceSend for &'arg mut $pri {
            type Target = Self;
        }
    };
}

impl_device_send!(bool);
impl_device_send!(i8);
impl_device_send!(i16);
impl_device_send!(i32);
impl_device_send!(i64);
impl_device_send!(i128);
impl_device_send!(isize);
impl_device_send!(u8);
impl_device_send!(u16);
impl_device_send!(u32);
impl_device_send!(u64);
impl_device_send!(u128);
impl_device_send!(usize);
impl_device_send!(f32);
impl_device_send!(f64);

accel_derive::define_launchable!(12 /* 0..=12 */);
