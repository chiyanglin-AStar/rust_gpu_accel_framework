//! Typed CUDA Kernel launcher
//!
//! This will be automatically implemented in [accel_derive::kernel] for autogenerated wrapper
//! module of [Module].
//!
//! ```
//! #[accel_derive::kernel]
//! fn f(a: i32) {}
//! ```
//!
//! will create a submodule `f`:
//!
//! ```
//! mod f {
//!     pub const PTX_STR: &str = "PTX string generated by rustc/nvptx64-nvidia-cuda";
//!     pub struct Module(::accel::Module);
//!     /* impl Module { ... } */
//!     /* impl Launchable for Module { ... } */
//! }
//! ```
//!
//! Implementation of `Launchable` for `f::Module` is also generated by [accel_derive::kernel]
//! proc-macro.
//!
//! [accel_derive::kernel]: https://docs.rs/accel-derive/0.3.0-alpha.1/accel_derive/attr.kernel.html
//! [Module]: struct.Module.html

use crate::{contexted_call, device::*, error::*, *};
use cuda::*;
use std::{ffi::*, ptr::null_mut};

/// Type which can be sent to the device as kernel argument
pub trait DeviceSend {
    /// Type on device
    type Target;
    fn as_kernel_parameter(&self) -> *mut c_void {
        self as *const Self as *mut c_void
    }
}

impl<T: Sized> DeviceSend for *mut T {
    type Target = Self;
}

impl<T: Sized> DeviceSend for *const T {
    type Target = Self;
}

macro_rules! impl_device_send {
    ($pri:ty) => {
        impl DeviceSend for $pri {
            type Target = Self;
        }

        impl<'arg> DeviceSend for &'arg $pri {
            type Target = Self;
        }

        impl<'arg> DeviceSend for &'arg mut $pri {
            type Target = Self;
        }
    };
}

impl_device_send!(bool);
impl_device_send!(i8);
impl_device_send!(i16);
impl_device_send!(i32);
impl_device_send!(i64);
impl_device_send!(i128);
impl_device_send!(isize);
impl_device_send!(u8);
impl_device_send!(u16);
impl_device_send!(u32);
impl_device_send!(u64);
impl_device_send!(u128);
impl_device_send!(usize);
impl_device_send!(f32);
impl_device_send!(f64);

accel_derive::define_launchable!(4);
